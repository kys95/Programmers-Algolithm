# 문제
1. 계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 
2. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.
3. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.
4. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 
5. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 
   나머지를 return 하도록 solution 함수를 작성해주세요.



# 해결과정
1. 오른쪽과 아래쪽으로만 움직이므로 경로의 갯수 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]임을 알 수 있다.
2. 모든 격자의 데이터를 담은 이중리스트 dp를 1로 초기화 하고 우물인 곳은 0으로 갱신한다.
3. 이중 for문으로 모든 인덱스를 탐색하여 우물인 경우, 집인 경우, 위쪽 벽인 경우, 왼쪽 벽인 경우, 왼쪽과 위쪽이 모두 우물인 경우, 나머지의 경우를
   분기하여 dp를 갱신한다.
4. 이렇게 풀고나니 코드가 너무 지저분하였다. 
5. 다시 생각해보니 x,y좌표 각각 인덱를 +1하여 IndexError를 방지하고 집과 웅덩이를 제외하고 다른 좌표를 
   dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 점화식에 맞추어 계산할 수 있었다.
6. 다른 코드를 살펴보니 재귀를 이용할 수 있었다.
7. 철저하게 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 점화식에 맞추어 딕셔너리 형태로 [((2, 1), 1), ((1, 2), 1))]로 초기화한다.
8. 이후에 우물인 좌표를 key값으로 info에 딕셔너리형태로 value 0으로 초기화한다.
9. setdefault함수를 이용하여 해당 key값이 없다면 value를 그대로 반환하고 있다면 그 value를 반환한다.
   